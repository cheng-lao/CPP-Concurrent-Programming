### Chapter one 

#### 什么是并发和多线程
1. 什么是并发

最简单和最基本的并发,是指两个或更多独立的活动同时发生。并发在生活中无处不在，我们可以边走边聊或者每只手做不同的动作，我们每个人彼此独立地过活--当我在游泳的时候你可以观看足球比赛，等等。**当我们从计算机视角讨论并发，指的是在单个系统里并行执行多个独立的任务，而非顺序地或者一个接一个的执行。** 

- 以前大多数台式机只有一个处理器，具有单个处理单元(processingunit)或核心(core)，如今很多台式机还是这样。这种机器在某一时刻只能执行一个任务，不过它每秒可以在任务间切换很多次。通过做一点这个任务，再做一点那个任务，循环往复的方式，让这些任务看起来是同时执行的。 **这叫做任务切换(taskswitching)。我们仍认为这样的系统是并发的:因为任务切换得太快，以至于无法区分在哪个点由于处理器切换到另个任务而挂起任务。** 任务切换会给用户和程序本身造成一种并发的假象。因为只是并发的假象，所以程序在单一处理器任务切换环境下的行为和在真正并发环境下略有不同。

- 多处理器计算机用于服务器和高性能计算已有多年，同时在单一芯片上有多个核的处理器(多核处理器)的台式机也越来越普遍。无论是多处理器或是多核的单处理器(或联合)，这些计算机都能够真正的并行执行多个任务。**我们称之为硬件并发(hardwareconcurrency)**

- 为了实现交替执行（任务切换），系统每次从一个任务切换到另一个时都需要执行一次上下文切换(context switch)，这需要时间开销。为了执行上下文切换，操作系统必须为当前运行的任务保存 CPU的状态和指令指针，然后算出要切换到哪个任务，并为即将切换到的任务重新加载处理器状态。CPU 潜在地需要将将指令和数据从内存加载到缓存中，这会阻止CPU执行任何指令，导致进一步的时延。

- 并发的实现方法有两种：第一种方法是使用**多个单线程的进程**，类似于让每个开发人员在自己的办公室，而第二种方法是**一个单一进程有多个线程**，好比一个办公室里有两个开发人员。（前者是多进程并发，后者是多线程并发）



#### 应用为什么要用并发和多线程

1. 关注点分离

- 编写软件时分离关注点几乎总是个好主意。通过将相关的代码聚合同时将无关的代码分离，可以使程序更易于理解和测试，从而更不容易出bug。**你可以使用并发来分离不同的功能区域，即使在这些不同区域上的操作需要同时发生;如果不显式地使用并发，那要么编写一个任务切换框架，要么在操作中主动地调用一段无关区域的代码。**

示例场景：
考虑一个有用户界面的处理密集型应用，比如台式机上的DVD播放程序。这样的应用程序，应具备两种基本功能:不光要从磁盘中读出数据，解码图像和声音，然后把它们及时地发送到图形和声音硬件，从而实现 DVD的无误播放，它还必须接受来自用户的输入，当用户点击“暂停”或“返回菜单”或“退出”按键的时候必须有所反应。当应用程序是单个线程时，应用需要在播放期间定期检查用户的输入，这需要把用户界面代码合并到DVD播放代码。如果使用多线程来分隔这些关注点，用户界面代码和DVD播放代码就不必交错在一起:一个线程可以处理用户界面，另一个进行DVD播放。它们之间会有交互，比如当用户点击暂停键时，但现在这些交互和手边的任务直接相关。

2. 提高性能

- **有两种利用并发来提高性能的方式:第一种也是最明显的，将单个任务分成几部分，且各自并行运行，从而降低总运行时间。这就是任务并行(taskparallelism)。** 虽然这听起来很直观，但它处理起来相当复杂，因为在各个部分之间可能存在大量的依赖。拆分要么是根据处理来进行--一个线程执行算法的一部分，而另一个线程执行算法的另一个部分--要么是基于数据来进行--每个线程在不同的数据部分上执行相同的操作。后一种方法被称为数据并行(dataparallelism)。

- **用并发提升性能的第二种方式是利用可用的并行来解决更大的问题:与其每次只处理一个文件，不如酌情处理2个、10个或20个。** 虽然这是数据并行的一种应用，即在多数据集上同时执行相同的操作，但侧重点不同。处理一个数据块仍然需要同样的时间，但在相同的时间内处理了更多的数据。显然，这种方法也有限制，且并非在所有情况下都能受益，但这种方法所带来的吞吐量提升，可以使某些事情成为可能--如果图片的不同区域能被并行地处理，就能以更高的分辨率来处理视频。



#### 何时不使用并发？

知道何时不使用并发与知道何时使用它一样重要。基本上，不使用并发的唯一原因就是收益比不上成本。使用并发的代码在很多情况下较难理解，因此编写和维护多线程代码会直接产生脑力成本，而额外的复杂性也可能会引发更多的bug。除非潜在的性能增益足够大或关注点分离的足够清晰，能抵消为确保代码逻辑正确所需的额外开发时间以及维护多线程代码相关的额外成本;否则，不要用并发。

- 如果在线程上的任务完成得很快，那么实际执行任务的时间要比启动线程的时间更短，这就会导致应用程序的整体性能还不如直接使用主线程(spawning thread)直接执行。
- 此外，线程是有限的资源。如果太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更慢。不仅如此，运行太多的线程也会耗光进程的可用内存或地址空间，因为每个线程都需要一个独立的堆栈空间。
- 为了提升性能而使用并发就像所有其他优化策略一样:它拥有大幅度提高应用性能的潜力，但它也可能让代码更加复杂，更难理解，并且更容易出bug。因此，应用中只有性能悠关并且有潜在重大收益的部分，才值得进行并发化。当然，如果潜在性能收益仅次于设计清晰或关注点分离，可能也值得使用多线程。

<!-- #### C++支持并发的一些历史
看不太懂说实话！
 -->



#### 一个简单的C++多线程程序长什么样

一开始没有C++多线程程序的结构
```cpp
#include<iostream>
using namespace std;


int main(){
    cout<< "Hello,World" << endl;
}
```


最基本的C++线程代码

```cpp
// Encode: UTF-8
#include<iostream>
#include<thread>    // 线程库

using namespace std;

void hello(){   // 添加了线程函数
    cout<< "Hello, Concurrent World! \n";
}

int main(int argc, char const *argv[])
{
    thread t(hello);    //添加了初始线程单元
    t.join();           //等到子线程结束
    return 0;
}

```
- 第一个区别是额外的#include<thread>，标准C++库中对多线程支持的声明在新的头文件中:管理线程的函数和类在<thread>中声明，而保护共享数据的函数和类在其他头文件中声明。
- 其次，写消息的代码被移动到了一个独立的函数中。因为每个线程都必须具有一个初始函数(initial function)，新线程的执行从这个函数开始。对于应用程序来说，初始线程是main()，但是对于其他线程，可以在std::thread对象的构造函数中指定--本例中，被命名为t的 std::thread 对象使用新函数 hello()作为其初始函数。
- 下一个区别:与直接写入标准输出或是从main0调用hello()不同，该程序启动了一个新的线程来实现，使线程数量增加到两个--初始线程始于main()，而新线程始于hello().
- 新的线程启动后，初始线程继续执行。如果它不等待新线程结束，它就将继续运行到main0)的结尾，从而结束程序--这有可能发生在新线程运行之前。这就是为什么在这里调用 join()的原因--详见第2章，这会使得调用线程(在 main()中)等待与std::thread对象相关联的线程，即这个例子中的t。
